
==================== FINAL INTERFACE ====================
2017-04-17 02:30:59.082883 UTC

interface main@main:Main 8002
  interface hash: 56e82676970d89b0ee3edb67ccd3528f
  ABI hash: 1a99e77077a0fdab2400ac201eb0e1da
  export-list hash: 7089c87ad9c2b199ab089592d20208d3
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: 438d6e88b012f549edca3d69e3231b42
  sig of: Nothing
  used TH splices: False
  where
exports:
  Main.final'
  Main.innerMost
  Main.lmiApply
  Main.main
  Main.second'
  Main.Identity{Main.Identity runIdentity}
  Main.MaybeT{Main.MaybeT runMaybeT}
module dependencies:
package dependencies: base-4.9.1.0* ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1
orphans: base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Either base-4.9.1.0:Data.Functor.Const
                         base-4.9.1.0:Data.Monoid base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:GHC.Generics base-4.9.1.0:GHC.IO.Exception
                         base-4.9.1.0:GHC.TypeLits
import  -/  base-4.9.1.0:Data.Functor 5ab1dc703df5b482e77efb697833ca3c
import  -/  base-4.9.1.0:GHC.Base c4231c43c07e46080a26bf94094c7aa1
import  -/  base-4.9.1.0:GHC.Show a027f5ac24879eaba752f44aa90fe511
import  -/  base-4.9.1.0:Prelude 22dd289b8469a8fa8dc81cab7b237771
import  -/  base-4.9.1.0:System.IO e4a64a8e3dce8616da54f0ee7104f7db
import  -/  ghc-prim-0.5.0.0:GHC.Classes 0bdf3d057a415ec1b84a7b1994efbe47
import  -/  ghc-prim-0.5.0.0:GHC.Types 89f8de4f08018c9177c98d979eae0e45
53cbae0bf2fc3985649fbd0a0b3e516e
  $fApplicativeIdentity :: GHC.Base.Applicative Main.Identity
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Main.Identity
                  Main.$fFunctorIdentity
                  Main.$fApplicativeIdentity_$cpure
                  Main.$fApplicativeIdentity_$c<*>
                  Main.$fApplicativeIdentity_$c*>
                  Main.$fApplicativeIdentity_$c<* -}
53cbae0bf2fc3985649fbd0a0b3e516e
  $fApplicativeIdentity1 ::
    Main.Identity a -> Main.Identity b -> Main.Identity a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,A>,
     Unfolding: InlineRule (2, True, True)
                (\ @ b @ a (eta :: Main.Identity a) (eta1 :: Main.Identity b) ->
                 eta) -}
53cbae0bf2fc3985649fbd0a0b3e516e
  $fApplicativeIdentity2 ::
    Main.Identity a -> Main.Identity b -> Main.Identity b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><S,1*U>,
     Unfolding: InlineRule (2, True, True)
                (\ @ b @ a (eta :: Main.Identity a) (eta1 :: Main.Identity b) ->
                 eta1) -}
53cbae0bf2fc3985649fbd0a0b3e516e
  $fApplicativeIdentity3 ::
    Main.Identity (a -> b) -> Main.Identity a -> b
  {- Arity: 2, HasNoCafRefs, Strictness: <C(S),1*C1(U)><L,U>,
     Unfolding: InlineRule (2, True, True)
                (\ @ a
                   @ b
                   (ds :: Main.Identity (a -> b))
                   (ds1 :: Main.Identity a) ->
                 ds `cast` (Main.N:Identity[0] <a -> b>_R)
                   ds1 `cast` (Main.N:Identity[0] <a>_R)) -}
0ee356e7a3b807d8a92fafe4fe1d5a1d
  $fApplicativeIdentity4 :: a -> a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True) (\ @ a (tpl :: a) -> tpl) -}
53cbae0bf2fc3985649fbd0a0b3e516e
  $fApplicativeIdentity_$c*> ::
    Main.Identity a -> Main.Identity b -> Main.Identity b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><S,1*U>,
     Unfolding: InlineRule (0, True, True)
                (\ @ a @ b -> Main.$fApplicativeIdentity2 @ b @ a) -}
53cbae0bf2fc3985649fbd0a0b3e516e
  $fApplicativeIdentity_$c<* ::
    Main.Identity a -> Main.Identity b -> Main.Identity a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,A>,
     Unfolding: InlineRule (0, True, True)
                (\ @ a @ b -> Main.$fApplicativeIdentity1 @ b @ a) -}
53cbae0bf2fc3985649fbd0a0b3e516e
  $fApplicativeIdentity_$c<*> ::
    Main.Identity (a -> b) -> Main.Identity a -> Main.Identity b
  {- Arity: 2, HasNoCafRefs, Strictness: <C(S),1*C1(U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Main.$fApplicativeIdentity3
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <Main.Identity (a -> b)>_R
                 ->_R <Main.Identity a>_R
                 ->_R Sym (Main.N:Identity[0] <b>_R)) -}
53cbae0bf2fc3985649fbd0a0b3e516e
  $fApplicativeIdentity_$cpure :: a -> Main.Identity a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Main.$fApplicativeIdentity4
                  `cast`
                (forall (a :: <*>_N). <a>_R ->_R Sym (Main.N:Identity[0] <a>_R)) -}
7320e140ffd76da4f302738251737d85
  $fApplicativeMaybeT ::
    GHC.Base.Applicative m => GHC.Base.Applicative (Main.MaybeT m)
  DFunId
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,U(U(C(C1(U)),A),C(U),C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ (m :: * -> *)
                      ($dApplicative :: GHC.Base.Applicative m).
                  @ (Main.MaybeT m)
                  (Main.$fApplicativeMaybeT_$cp1Applicative @ m $dApplicative)
                  (Main.$fApplicativeMaybeT_$cpure @ m $dApplicative)
                  (Main.$fApplicativeMaybeT_$c<*> @ m $dApplicative)
                  (Main.$fApplicativeMaybeT_$c*> @ m $dApplicative)
                  (Main.$fApplicativeMaybeT_$c<* @ m $dApplicative) -}
7320e140ffd76da4f302738251737d85
  $fApplicativeMaybeT1 ::
    GHC.Base.Applicative m =>
    forall a b.
    Main.MaybeT m a -> Main.MaybeT m b -> m (GHC.Base.Maybe a)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LLC(C(S))LL),U(U(C(C1(U)),A),A,1*C1(C1(U)),A,A)><L,U><L,U>,
     Unfolding: (\ @ (m :: * -> *)
                   ($dApplicative :: GHC.Base.Applicative m)
                   @ a
                   @ b
                   (eta :: Main.MaybeT m a)
                   (eta1 :: Main.MaybeT m b) ->
                 GHC.Base.<*>
                   @ m
                   $dApplicative
                   @ (GHC.Base.Maybe b)
                   @ (GHC.Base.Maybe a)
                   (GHC.Base.fmap
                      @ m
                      (GHC.Base.$p1Applicative @ m $dApplicative)
                      @ (GHC.Base.Maybe (b -> a))
                      @ (GHC.Base.Maybe b -> GHC.Base.Maybe a)
                      (GHC.Base.$fApplicativeMaybe_$c<*> @ b @ a)
                      (GHC.Base.fmap
                         @ m
                         (GHC.Base.$p1Applicative @ m $dApplicative)
                         @ (GHC.Base.Maybe a)
                         @ (GHC.Base.Maybe (b -> a))
                         (Main.$fApplicativeMaybeT2 @ b @ a)
                         eta `cast` (Main.N:MaybeT[0] <m>_R <a>_N)))
                   eta1 `cast` (Main.N:MaybeT[0] <m>_R <b>_N)) -}
a7ef7ee6e462a6d2f86a1968de6c96f0
  $fApplicativeMaybeT2 :: GHC.Base.Maybe a -> GHC.Base.Maybe (b -> a)
  {- Arity: 1, HasNoCafRefs,
     Unfolding: (\ @ b @ a (m1 :: GHC.Base.Maybe a) ->
                 case m1 of wild {
                   GHC.Base.Nothing -> GHC.Base.Nothing @ (b -> a)
                   GHC.Base.Just x
                   -> GHC.Base.Just @ (b -> a) (\ (ds :: b) -> x) }) -}
7320e140ffd76da4f302738251737d85
  $fApplicativeMaybeT3 ::
    GHC.Base.Applicative m =>
    forall a b.
    Main.MaybeT m a -> Main.MaybeT m b -> m (GHC.Base.Maybe b)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LLC(C(S))LL),U(U(C(C1(U)),A),A,1*C1(C1(U)),A,A)><L,U><L,U>,
     Unfolding: (\ @ (m :: * -> *)
                   ($dApplicative :: GHC.Base.Applicative m)
                   @ a
                   @ b
                   (eta :: Main.MaybeT m a)
                   (eta1 :: Main.MaybeT m b) ->
                 GHC.Base.<*>
                   @ m
                   $dApplicative
                   @ (GHC.Base.Maybe b)
                   @ (GHC.Base.Maybe b)
                   (GHC.Base.fmap
                      @ m
                      (GHC.Base.$p1Applicative @ m $dApplicative)
                      @ (GHC.Base.Maybe (b -> b))
                      @ (GHC.Base.Maybe b -> GHC.Base.Maybe b)
                      (GHC.Base.$fApplicativeMaybe_$c<*> @ b @ b)
                      (GHC.Base.fmap
                         @ m
                         (GHC.Base.$p1Applicative @ m $dApplicative)
                         @ (GHC.Base.Maybe a)
                         @ (GHC.Base.Maybe (b -> b))
                         (Main.$fApplicativeMaybeT4 @ b @ a)
                         eta `cast` (Main.N:MaybeT[0] <m>_R <a>_N)))
                   eta1 `cast` (Main.N:MaybeT[0] <m>_R <b>_N)) -}
92e319175f2f2c5e59f621550a20dc0c
  $fApplicativeMaybeT4 :: GHC.Base.Maybe a -> GHC.Base.Maybe (b -> b)
  {- Arity: 1, HasNoCafRefs,
     Unfolding: (\ @ b @ a (m1 :: GHC.Base.Maybe a) ->
                 case m1 of wild {
                   GHC.Base.Nothing -> GHC.Base.Nothing @ (b -> b)
                   GHC.Base.Just x -> Main.$fApplicativeMaybeT5 @ b }) -}
5d59690adbae956ac1f19a78e266f718
  $fApplicativeMaybeT5 :: GHC.Base.Maybe (b -> b)
  {- HasNoCafRefs,
     Unfolding: (\ @ b ->
                 GHC.Base.Just @ (b -> b) (GHC.Base.breakpoint @ b)) -}
7320e140ffd76da4f302738251737d85
  $fApplicativeMaybeT6 ::
    GHC.Base.Applicative m =>
    forall a b.
    Main.MaybeT m (a -> b) -> Main.MaybeT m a -> m (GHC.Base.Maybe b)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LLC(C(S))LL),U(1*U(1*C1(C1(U)),A),A,1*C1(C1(U)),A,A)><L,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ (m :: * -> *)
                   ($dApplicative :: GHC.Base.Applicative m)
                   @ a
                   @ b
                   (eta :: Main.MaybeT m (a -> b))
                   (eta1 :: Main.MaybeT m a) ->
                 GHC.Base.<*>
                   @ m
                   $dApplicative
                   @ (GHC.Base.Maybe a)
                   @ (GHC.Base.Maybe b)
                   (GHC.Base.fmap
                      @ m
                      (GHC.Base.$p1Applicative @ m $dApplicative)
                      @ (GHC.Base.Maybe (a -> b))
                      @ (GHC.Base.Maybe a -> GHC.Base.Maybe b)
                      (GHC.Base.$fApplicativeMaybe_$c<*> @ a @ b)
                      eta `cast` (Main.N:MaybeT[0] <m>_R <a -> b>_N))
                   eta1 `cast` (Main.N:MaybeT[0] <m>_R <a>_N)) -}
6ce9f64a79ce4ba069a6c5b526e175b9
  $fApplicativeMaybeT7 ::
    GHC.Base.Applicative m => forall a. a -> m (GHC.Base.Maybe a)
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LC(S)LLL),1*U(A,1*C1(U),A,A,A)><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ @ (m :: * -> *)
                   ($dApplicative :: GHC.Base.Applicative m)
                   @ a
                   (x :: a) ->
                 GHC.Base.pure
                   @ m
                   $dApplicative
                   @ (GHC.Base.Maybe a)
                   (GHC.Base.Just @ a x)) -}
7320e140ffd76da4f302738251737d85
  $fApplicativeMaybeT_$c*> ::
    GHC.Base.Applicative m =>
    forall a b. Main.MaybeT m a -> Main.MaybeT m b -> Main.MaybeT m b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LLC(C(S))LL),U(U(C(C1(U)),A),A,1*C1(C1(U)),A,A)><L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                Main.$fApplicativeMaybeT3
                  `cast`
                (forall (m :: <* -> *>_N).
                 <GHC.Base.Applicative m>_R
                 ->_R forall (a :: <*>_N) (b :: <*>_N).
                      <Main.MaybeT m a>_R
                      ->_R <Main.MaybeT m b>_R
                      ->_R Sym (Main.N:MaybeT[0] <m>_R <b>_N)) -}
7320e140ffd76da4f302738251737d85
  $fApplicativeMaybeT_$c<* ::
    GHC.Base.Applicative m =>
    forall a b. Main.MaybeT m a -> Main.MaybeT m b -> Main.MaybeT m a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LLC(C(S))LL),U(U(C(C1(U)),A),A,1*C1(C1(U)),A,A)><L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                Main.$fApplicativeMaybeT1
                  `cast`
                (forall (m :: <* -> *>_N).
                 <GHC.Base.Applicative m>_R
                 ->_R forall (a :: <*>_N) (b :: <*>_N).
                      <Main.MaybeT m a>_R
                      ->_R <Main.MaybeT m b>_R
                      ->_R Sym (Main.N:MaybeT[0] <m>_R <a>_N)) -}
7320e140ffd76da4f302738251737d85
  $fApplicativeMaybeT_$c<*> ::
    GHC.Base.Applicative m =>
    forall a b.
    Main.MaybeT m (a -> b) -> Main.MaybeT m a -> Main.MaybeT m b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(LLC(C(S))LL),U(1*U(1*C1(C1(U)),A),A,1*C1(C1(U)),A,A)><L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                Main.$fApplicativeMaybeT6
                  `cast`
                (forall (m :: <* -> *>_N).
                 <GHC.Base.Applicative m>_R
                 ->_R forall (a :: <*>_N) (b :: <*>_N).
                      <Main.MaybeT m (a -> b)>_R
                      ->_R <Main.MaybeT m a>_R
                      ->_R Sym (Main.N:MaybeT[0] <m>_R <b>_N)) -}
7320e140ffd76da4f302738251737d85
  $fApplicativeMaybeT_$cp1Applicative ::
    GHC.Base.Applicative m => GHC.Base.Functor (Main.MaybeT m)
  {- Arity: 1, HasNoCafRefs,
     Strictness: <L,1*U(1*U(C(C1(U)),A),A,A,A,A)>m,
     Unfolding: InlineRule (1, True, False)
                (\ @ (m :: * -> *) ($dApplicative :: GHC.Base.Applicative m) ->
                 Main.$fFunctorMaybeT
                   @ m
                   (GHC.Base.$p1Applicative @ m $dApplicative)) -}
7320e140ffd76da4f302738251737d85
  $fApplicativeMaybeT_$cpure ::
    GHC.Base.Applicative m => forall a. a -> Main.MaybeT m a
  {- Arity: 2, HasNoCafRefs,
     Strictness: <S(LC(S)LLL),1*U(A,1*C1(U),A,A,A)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Main.$fApplicativeMaybeT7
                  `cast`
                (forall (m :: <* -> *>_N).
                 <GHC.Base.Applicative m>_R
                 ->_R forall (a :: <*>_N).
                      <a>_R ->_R Sym (Main.N:MaybeT[0] <m>_R <a>_N)) -}
53cbae0bf2fc3985649fbd0a0b3e516e
  $fEqIdentity ::
    GHC.Classes.Eq a => GHC.Classes.Eq (Main.Identity a)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(1*U,1*U)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dEq :: GHC.Classes.Eq a).
                  @ (Main.Identity a)
                  (Main.$fEqIdentity_$c== @ a $dEq)
                  (Main.$fEqIdentity_$c/= @ a $dEq) -}
53cbae0bf2fc3985649fbd0a0b3e516e
  $fEqIdentity_$c/= ::
    GHC.Classes.Eq a =>
    Main.Identity a -> Main.Identity a -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S(LS),U(A,U)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Classes./=
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Classes.Eq a>_R
                 ->_R Sym (Main.N:Identity[0] <a>_R)
                 ->_R Sym (Main.N:Identity[0] <a>_R)
                 ->_R <GHC.Types.Bool>_R) -}
53cbae0bf2fc3985649fbd0a0b3e516e
  $fEqIdentity_$c== ::
    GHC.Classes.Eq a =>
    Main.Identity a -> Main.Identity a -> GHC.Types.Bool
  {- Arity: 1, HasNoCafRefs, Strictness: <S(SL),U(U,A)>,
     Unfolding: InlineRule (0, True, True)
                GHC.Classes.==
                  `cast`
                (forall (a :: <*>_N).
                 <GHC.Classes.Eq a>_R
                 ->_R Sym (Main.N:Identity[0] <a>_R)
                 ->_R Sym (Main.N:Identity[0] <a>_R)
                 ->_R <GHC.Types.Bool>_R) -}
53cbae0bf2fc3985649fbd0a0b3e516e
  $fFunctorIdentity :: GHC.Base.Functor Main.Identity
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Main.Identity
                  Main.$fFunctorIdentity_$cfmap
                  Main.$fFunctorIdentity_$c<$ -}
53cbae0bf2fc3985649fbd0a0b3e516e
  $fFunctorIdentity1 :: a -> Main.Identity b -> a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,A>,
     Unfolding: InlineRule (2, True, True)
                (\ @ b @ a (eta :: a) (ds :: Main.Identity b) -> eta) -}
53cbae0bf2fc3985649fbd0a0b3e516e
  $fFunctorIdentity2 :: (a -> b) -> Main.Identity a -> b
  {- Arity: 2, HasNoCafRefs, Strictness: <C(S),1*C1(U)><L,U>,
     Unfolding: InlineRule (2, True, True)
                (\ @ a @ b (f :: a -> b) (ds :: Main.Identity a) ->
                 f ds `cast` (Main.N:Identity[0] <a>_R)) -}
53cbae0bf2fc3985649fbd0a0b3e516e
  $fFunctorIdentity_$c<$ :: a -> Main.Identity b -> Main.Identity a
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,A>,
     Unfolding: InlineRule (0, True, True)
                (\ @ a @ b -> Main.$fFunctorIdentity1 @ b @ a)
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <a>_R
                 ->_R <Main.Identity b>_R
                 ->_R Sym (Main.N:Identity[0] <a>_R)) -}
53cbae0bf2fc3985649fbd0a0b3e516e
  $fFunctorIdentity_$cfmap ::
    (a -> b) -> Main.Identity a -> Main.Identity b
  {- Arity: 2, HasNoCafRefs, Strictness: <C(S),1*C1(U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Main.$fFunctorIdentity2
                  `cast`
                (forall (a :: <*>_N) (b :: <*>_N).
                 <a -> b>_R
                 ->_R <Main.Identity a>_R
                 ->_R Sym (Main.N:Identity[0] <b>_R)) -}
7320e140ffd76da4f302738251737d85
  $fFunctorMaybeT ::
    GHC.Base.Functor m => GHC.Base.Functor (Main.MaybeT m)
  DFunId
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U(C(C1(U)),A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ (m :: * -> *) ($dFunctor :: GHC.Base.Functor m).
                  @ (Main.MaybeT m)
                  (Main.$fFunctorMaybeT_$cfmap @ m $dFunctor)
                  (Main.$fFunctorMaybeT_$c<$ @ m $dFunctor) -}
7320e140ffd76da4f302738251737d85
  $fFunctorMaybeT1 ::
    GHC.Base.Functor m =>
    forall a b. a -> Main.MaybeT m b -> m (GHC.Base.Maybe a)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ (m :: * -> *)
                   ($dFunctor :: GHC.Base.Functor m)
                   @ a
                   @ b
                   (eta :: a)
                   (eta1 :: Main.MaybeT m b) ->
                 GHC.Base.fmap
                   @ m
                   $dFunctor
                   @ (GHC.Base.Maybe b)
                   @ (GHC.Base.Maybe a)
                   (\ (m1 :: GHC.Base.Maybe b) ->
                    case m1 of wild {
                      GHC.Base.Nothing -> GHC.Base.Nothing @ a
                      GHC.Base.Just x -> GHC.Base.Just @ a eta })
                   eta1 `cast` (Main.N:MaybeT[0] <m>_R <b>_N)) -}
7320e140ffd76da4f302738251737d85
  $fFunctorMaybeT2 ::
    GHC.Base.Functor m =>
    forall a b. (a -> b) -> Main.MaybeT m a -> m (GHC.Base.Maybe b)
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,C(U)><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ (m :: * -> *)
                   ($dFunctor :: GHC.Base.Functor m)
                   @ a
                   @ b
                   (f :: a -> b)
                   (ds :: Main.MaybeT m a) ->
                 GHC.Base.fmap
                   @ m
                   $dFunctor
                   @ (GHC.Base.Maybe a)
                   @ (GHC.Base.Maybe b)
                   (GHC.Base.$fApplicativeMaybe_$sliftM @ a @ b f)
                   ds `cast` (Main.N:MaybeT[0] <m>_R <a>_N)) -}
7320e140ffd76da4f302738251737d85
  $fFunctorMaybeT_$c<$ ::
    GHC.Base.Functor m =>
    forall a b. a -> Main.MaybeT m b -> Main.MaybeT m a
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                Main.$fFunctorMaybeT1
                  `cast`
                (forall (m :: <* -> *>_N).
                 <GHC.Base.Functor m>_R
                 ->_R forall (a :: <*>_N) (b :: <*>_N).
                      <a>_R
                      ->_R <Main.MaybeT m b>_R
                      ->_R Sym (Main.N:MaybeT[0] <m>_R <a>_N)) -}
7320e140ffd76da4f302738251737d85
  $fFunctorMaybeT_$cfmap ::
    GHC.Base.Functor m =>
    forall a b. (a -> b) -> Main.MaybeT m a -> Main.MaybeT m b
  {- Arity: 3, HasNoCafRefs,
     Strictness: <S(C(C(S))L),1*U(1*C1(C1(U)),A)><L,C(U)><L,U>,
     Unfolding: InlineRule (0, True, True)
                Main.$fFunctorMaybeT2
                  `cast`
                (forall (m :: <* -> *>_N).
                 <GHC.Base.Functor m>_R
                 ->_R forall (a :: <*>_N) (b :: <*>_N).
                      <a -> b>_R
                      ->_R <Main.MaybeT m a>_R
                      ->_R Sym (Main.N:MaybeT[0] <m>_R <b>_N)) -}
53cbae0bf2fc3985649fbd0a0b3e516e
  $fMonadIdentity :: GHC.Base.Monad Main.Identity
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Main.Identity
                  Main.$fApplicativeIdentity
                  Main.$fMonadIdentity_$c>>=
                  Main.$fMonadIdentity_$c>>
                  Main.$fApplicativeIdentity_$cpure
                  Main.$fMonadIdentity_$s$dmfail -}
53cbae0bf2fc3985649fbd0a0b3e516e
  $fMonadIdentity_$c>> ::
    Main.Identity a -> Main.Identity b -> Main.Identity b
  {- Arity: 2, Strictness: <L,U><L,U>, Inline: INLINE (sat-args=2),
     Unfolding: InlineRule (2, False, False)
                (\ @ a @ b (m1 :: Main.Identity a) (k :: Main.Identity b) ->
                 Main.$fMonadIdentity_$c>>=
                   @ a
                   @ b
                   m1
                   (\ (ds :: a)[OneShot] -> k)) -}
53cbae0bf2fc3985649fbd0a0b3e516e
  $fMonadIdentity_$c>>= ::
    Main.Identity a -> (a -> Main.Identity b) -> Main.Identity b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,U><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ @ a @ b (ds :: Main.Identity a) (f :: a -> Main.Identity b) ->
                 f ds `cast` (Main.N:Identity[0] <a>_R)) -}
53cbae0bf2fc3985649fbd0a0b3e516e
  $fMonadIdentity_$s$dmfail :: GHC.Base.String -> Main.Identity a
  {- Arity: 1, Strictness: <B,U>x,
     Unfolding: InlineRule (-1, True, True)
                (\ @ a (s :: GHC.Base.String) ->
                 GHC.Err.errorWithoutStackTrace
                   @ 'GHC.Types.PtrRepLifted
                   @ (Main.Identity a)
                   s) -}
53cbae0bf2fc3985649fbd0a0b3e516e
  $fShowIdentity ::
    GHC.Show.Show a => GHC.Show.Show (Main.Identity a)
  DFunId
  {- Arity: 1, Strictness: <L,U(C(C1(U)),A,A)>m,
     Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun: @ a ($dShow :: GHC.Show.Show a).
                  @ (Main.Identity a)
                  (Main.$fShowIdentity_$cshowsPrec @ a $dShow)
                  (Main.$fShowIdentity_$cshow @ a $dShow)
                  (Main.$fShowIdentity_$cshowList @ a $dShow) -}
b791430c4b353c757a98502218c504b8
  $fShowIdentity1 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
9ea4a681030015a439fc226aad897353
  $fShowIdentity2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "}"#) -}
7ea381b2c5de049def22fadfa880d078
  $fShowIdentity3 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "runIdentity = "#) -}
a26d3561504c3e861340cb963f26497c
  $fShowIdentity4 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Identity {"#) -}
834ab93ee19baa76845ace43502f0245
  $fShowIdentity5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.Base.++
                   @ GHC.Types.Char
                   Main.$fShowIdentity2
                   (GHC.Types.[] @ GHC.Types.Char)) -}
53cbae0bf2fc3985649fbd0a0b3e516e
  $fShowIdentity_$cshow ::
    GHC.Show.Show a => Main.Identity a -> GHC.Base.String
  {- Arity: 2, Strictness: <L,1*U(1*C1(C1(C1(U))),A,A)><L,U>,
     Unfolding: (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (x :: Main.Identity a) ->
                 GHC.Base.++
                   @ GHC.Types.Char
                   Main.$fShowIdentity4
                   (GHC.Base.++
                      @ GHC.Types.Char
                      Main.$fShowIdentity3
                      (GHC.Show.showsPrec
                         @ a
                         $dShow
                         Main.$fShowIdentity1
                         x `cast` (Main.N:Identity[0] <a>_R)
                         Main.$fShowIdentity5))) -}
53cbae0bf2fc3985649fbd0a0b3e516e
  $fShowIdentity_$cshowList ::
    GHC.Show.Show a => [Main.Identity a] -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,U(C(C1(U)),A,A)><S,1*U><L,U>,
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   ($dShow :: GHC.Show.Show a)
                   (eta :: [Main.Identity a])
                   (eta1 :: GHC.Base.String) ->
                 GHC.Show.showList__
                   @ (Main.Identity a)
                   (Main.$fShowIdentity_$cshowsPrec @ a $dShow Main.$fShowIdentity1)
                   eta
                   eta1) -}
53cbae0bf2fc3985649fbd0a0b3e516e
  $fShowIdentity_$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Types.Int -> Main.Identity a -> GHC.Show.ShowS
  {- Arity: 3,
     Strictness: <L,1*U(1*C1(C1(U)),A,A)><S(S),1*U(U)><L,U>,
     Inline: INLINE[0],
     Unfolding: InlineRule (3, True, False)
                (\ @ a
                   (w :: GHC.Show.Show a)
                   (w1 :: GHC.Types.Int)
                   (w2 :: Main.Identity a) ->
                 case w1 of ww { GHC.Types.I# ww1 ->
                 Main.$w$cshowsPrec @ a w ww1 w2 }) -}
fb6ed5929bece2c052127313cb24c106
  $tc'Identity :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2029112138846393583##
                   2905385520651452197##
                   Main.$trModule
                   Main.$tc'Identity1) -}
d66c2f8db5a22ef38960484a4b9f37e2
  $tc'Identity1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Identity"#) -}
a466e0d49cd9fd624ec429b3c3c6067a
  $tc'MaybeT :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   715124187048119754##
                   14575319056458782753##
                   Main.$trModule
                   Main.$tc'MaybeT1) -}
da6625446b0465228a7c4d4c2e95857e
  $tc'MaybeT1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'MaybeT"#) -}
7f9137da72f6c5793b3d621bfaad5de1
  $tcIdentity :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   1219351100840430795##
                   4195889340468339127##
                   Main.$trModule
                   Main.$tcIdentity1) -}
8223c0a29bd099943619ea59d112c6ea
  $tcIdentity1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Identity"#) -}
6fb8abf83621794be558fb71dbe31346
  $tcMaybeT :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   14481343367772008007##
                   14796151857454751779##
                   Main.$trModule
                   Main.$tcMaybeT1) -}
4ffc37f992117995761739dca778d093
  $tcMaybeT1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "MaybeT"#) -}
d6831ef04cb9301b090dfae6f7bb7ec7
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module Main.$trModule2 Main.$trModule1) -}
847d9fc3b8e6f0b424199f36b4999bb2
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Main"#) -}
24ef6042833e75ffd7aa98b83ecca98d
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "main"#) -}
53cbae0bf2fc3985649fbd0a0b3e516e
  $w$cshowsPrec ::
    GHC.Show.Show a =>
    GHC.Prim.Int# -> Main.Identity a -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(1*C1(C1(U)),A,A)><S,U><L,U>,
     Inline: [0],
     Unfolding: (\ @ a
                   (w :: GHC.Show.Show a)
                   (ww :: GHC.Prim.Int#)
                   (w1 :: Main.Identity a) ->
                 let {
                   f :: GHC.Base.String -> GHC.Base.String
                   = GHC.Show.showsPrec
                       @ a
                       w
                       Main.$fShowIdentity1
                       w1 `cast` (Main.N:Identity[0] <a>_R)
                 } in
                 let {
                   p :: GHC.Show.ShowS {- Arity: 1, Strictness: <L,1*U> -}
                   = \ (x :: GHC.Base.String) ->
                     GHC.Base.++
                       @ GHC.Types.Char
                       Main.$fShowIdentity4
                       (GHC.Base.++
                          @ GHC.Types.Char
                          Main.$fShowIdentity3
                          (f (GHC.Base.++ @ GHC.Types.Char Main.$fShowIdentity2 x)))
                 } in
                 case GHC.Prim.tagToEnum#
                        @ GHC.Types.Bool
                        (GHC.Prim.>=# ww 11#) of wild {
                   GHC.Types.False -> p
                   GHC.Types.True
                   -> \ (x :: GHC.Base.String) ->
                      GHC.Types.:
                        @ GHC.Types.Char
                        GHC.Show.shows7
                        (p (GHC.Types.: @ GHC.Types.Char GHC.Show.shows4 x)) }) -}
53cbae0bf2fc3985649fbd0a0b3e516e
  newtype Identity a = Identity {runIdentity :: a}
7320e140ffd76da4f302738251737d85
  type role MaybeT representational nominal
  newtype MaybeT (m :: * -> *) a
    = MaybeT {runMaybeT :: m (GHC.Base.Maybe a)}
27ff5a63013e59e304e63267a1ae21d4
  final' ::
    [GHC.Base.Maybe (Main.Identity a)
     -> GHC.Base.Maybe (Main.Identity b)]
    -> [GHC.Base.Maybe (Main.Identity a)]
    -> [GHC.Base.Maybe (Main.Identity b)]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>,
     Unfolding: InlineRule (0, True, True)
                (\ @ a @ b ->
                 GHC.Base.$fApplicative[]_$c<*>
                   @ (GHC.Base.Maybe (Main.Identity a))
                   @ (GHC.Base.Maybe (Main.Identity b))) -}
35341ab555dacdd4f9cc8fd44ce5603d
  innerMost ::
    [GHC.Base.Maybe (Main.Identity (a -> b))]
    -> [GHC.Base.Maybe (Main.Identity a -> Main.Identity b)]
  {- Arity: 1, HasNoCafRefs,
     Unfolding: (\ @ a @ b ->
                 GHC.Base.map
                   @ (GHC.Base.Maybe (Main.Identity (a -> b)))
                   @ (GHC.Base.Maybe (Main.Identity a -> Main.Identity b))
                   (Main.innerMost1 @ a @ b)) -}
c26a0c9651f626f5f952828186e4129f
  innerMost1 ::
    GHC.Base.Maybe (Main.Identity (a -> b))
    -> GHC.Base.Maybe (Main.Identity a -> Main.Identity b)
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ @ a @ b (m1 :: GHC.Base.Maybe (Main.Identity (a -> b))) ->
                 case m1 of wild {
                   GHC.Base.Nothing
                   -> GHC.Base.Nothing @ (Main.Identity a -> Main.Identity b)
                   GHC.Base.Just x
                   -> GHC.Base.Just
                        @ (Main.Identity a -> Main.Identity b)
                        (\ (ds :: Main.Identity a) ->
                         x `cast` (Main.N:Identity[0] <a -> b>_R)
                           ds `cast` (Main.N:Identity[0] <a>_R))
                          `cast`
                        (<Main.Identity a>_R ->_R Sym (Main.N:Identity[0] <b>_R)) }) -}
93da17f058cb17c77262a240ad954dcf
  lmiApply ::
    [GHC.Base.Maybe (Main.Identity (a -> b))]
    -> [GHC.Base.Maybe (Main.Identity a)]
    -> [GHC.Base.Maybe (Main.Identity b)]
  {- Arity: 2, HasNoCafRefs, Strictness: <S,1*U><L,U>,
     Unfolding: (\ @ a
                   @ b
                   (f :: [GHC.Base.Maybe (Main.Identity (a -> b))])
                   (x :: [GHC.Base.Maybe (Main.Identity a)]) ->
                 letrec {
                   go :: [GHC.Base.Maybe (Main.Identity (a -> b))]
                         -> [GHC.Base.Maybe (Main.Identity b)]
                     {- Arity: 1, Strictness: <S,1*U> -}
                   = \ (ds :: [GHC.Base.Maybe (Main.Identity (a -> b))]) ->
                     case ds of wild {
                       [] -> GHC.Types.[] @ (GHC.Base.Maybe (Main.Identity b))
                       : y ys
                       -> let {
                            ys1 :: [GHC.Base.Maybe (Main.Identity b)] = go ys
                          } in
                          letrec {
                            go1 :: [GHC.Base.Maybe (Main.Identity a)]
                                   -> [GHC.Base.Maybe (Main.Identity b)]
                              {- Arity: 1, Strictness: <S,1*U> -}
                            = \ (ds1 :: [GHC.Base.Maybe (Main.Identity a)]) ->
                              case ds1 of wild1 {
                                [] -> ys1
                                : y1 ys2
                                -> GHC.Types.:
                                     @ (GHC.Base.Maybe (Main.Identity b))
                                     (case y of wild2 {
                                        GHC.Base.Nothing -> GHC.Base.Nothing @ (Main.Identity b)
                                        GHC.Base.Just x1
                                        -> case y1 of wild3 {
                                             GHC.Base.Nothing
                                             -> GHC.Base.Nothing @ (Main.Identity b)
                                             GHC.Base.Just x2
                                             -> GHC.Base.Just
                                                  @ (Main.Identity b)
                                                  (x1 `cast` (Main.N:Identity[0] <a -> b>_R)
                                                     x2 `cast` (Main.N:Identity[0] <a>_R))
                                                    `cast`
                                                  (Sym (Main.N:Identity[0] <b>_R)) } })
                                     (go1 ys2) }
                          } in
                          go1 x }
                 } in
                 go f) -}
549e997b77251cffa539541e3fca551d
  main :: GHC.Types.IO ()
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: InlineRule (0, True, True)
                Main.main1 `cast` (Sym (GHC.Types.N:IO[0] <()>_R)) -}
12f13e20d189575a2f38fa0188d46990
  main1 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1, Strictness: <S,U>,
     Unfolding: (\ (eta :: GHC.Prim.State#
                             GHC.Prim.RealWorld)[OneShot] ->
                 GHC.IO.Handle.Text.hPutStr2
                   GHC.IO.Handle.FD.stdout
                   Main.main2
                   GHC.Types.True
                   eta) -}
5ca9aae8b1fa510e4d7ba6c699a49ec7
  main2 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "hello world"#) -}
eaf959ce78010a9f5591044b85b85e4b
  main3 ::
    GHC.Prim.State# GHC.Prim.RealWorld
    -> (# GHC.Prim.State# GHC.Prim.RealWorld, () #)
  {- Arity: 1,
     Unfolding: (GHC.TopHandler.runMainIO1
                   @ ()
                   Main.main1 `cast` (Sym (GHC.Types.N:IO[0] <()>_R))) -}
b4ef9bfa4d8f50c982c4ebba238f5846
  runIdentity :: Main.Identity a -> a
  RecSel Left Main.Identity
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Main.runIdentity1
                  `cast`
                (forall (a :: <*>_N).
                 <Main.Identity a>_R ->_R Main.N:Identity[0] <a>_R) -}
bbd1d4cd5549c1ec9312e4ddf639b619
  runIdentity1 :: Main.Identity a -> Main.Identity a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True)
                (\ @ a (ds :: Main.Identity a) -> ds) -}
4c68ec6b891f64581a70c20631795df0
  runMaybeT :: Main.MaybeT m a -> m (GHC.Base.Maybe a)
  RecSel Left Main.MaybeT
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (0, True, True)
                Main.runMaybeT1
                  `cast`
                (forall (m :: <* -> *>_N) (a :: <*>_N).
                 <Main.MaybeT m a>_R ->_R Main.N:MaybeT[0] <m>_R <a>_N) -}
5e05ba5d410f1ba975091c5973b96725
  runMaybeT1 :: Main.MaybeT m a -> Main.MaybeT m a
  {- Arity: 1, HasNoCafRefs, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, True)
                (\ @ (m :: * -> *) @ a (ds :: Main.MaybeT m a) -> ds) -}
793c9e829139e6c2e62b0849a900739d
  second' ::
    [GHC.Base.Maybe (Main.Identity a -> Main.Identity b)]
    -> [GHC.Base.Maybe (Main.Identity a)
        -> GHC.Base.Maybe (Main.Identity b)]
  {- Arity: 1, HasNoCafRefs,
     Unfolding: (\ @ a @ b ->
                 GHC.Base.map
                   @ (GHC.Base.Maybe (Main.Identity a -> Main.Identity b))
                   @ (GHC.Base.Maybe (Main.Identity a)
                      -> GHC.Base.Maybe (Main.Identity b))
                   (GHC.Base.$fApplicativeMaybe_$c<*>
                      @ (Main.Identity a)
                      @ (Main.Identity b))) -}
instance [safe] GHC.Base.Applicative [Main.Identity]
  = Main.$fApplicativeIdentity
instance [safe] GHC.Base.Applicative [Main.MaybeT]
  = Main.$fApplicativeMaybeT
instance [safe] GHC.Classes.Eq [Main.Identity] = Main.$fEqIdentity
instance [safe] GHC.Base.Functor [Main.Identity]
  = Main.$fFunctorIdentity
instance [safe] GHC.Base.Functor [Main.MaybeT]
  = Main.$fFunctorMaybeT
instance [safe] GHC.Base.Monad [Main.Identity]
  = Main.$fMonadIdentity
instance [safe] GHC.Show.Show [Main.Identity] = Main.$fShowIdentity
"SPEC/Main $dmfail @ Identity" [ALWAYS] forall ($dMonad :: GHC.Base.Monad
                                                             Main.Identity)
  GHC.Base.$dmfail @ Main.Identity $dMonad
  = Main.$fMonadIdentity_$s$dmfail
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

